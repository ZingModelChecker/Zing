enum Machine { Ping, Pong };

enum Event {_Ping, _Pong, _Success};

enum PING_State {_Ping_Init, _Ping_SendPing, _Ping_WaitPong};

enum PONG_State {_Pong_WaitPing, _Pong_SendPong};

class PING{
SM_EVENT_SET stackDeferredSet;
SM_HANDLE __self;
SM_HANDLE pongId;
void runHelper(PING_State startState) {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET savedDeferredSet;
SM_ARG_UNION payload;
bool nondet;


if (startState == PING_State._Ping_WaitPong) {
goto execute_Ping_WaitPong;
} else {
if (startState == PING_State._Ping_SendPing) {
goto execute_Ping_SendPing;
} else {
if (startState == PING_State._Ping_Init) {
goto execute_Ping_Init;
} else {
assert(false);

}

}

}


execute_Ping_Init:
trace("<StateLog> Machine {0}-{1} entered State {2}", __self.machineName, __self.instance, PING_State._Ping_Init);
pongId = Main.CreateMachine_PONG();
__self.currentEvent = Main.Success_SM_EVENT;
goto transition_Ping_Init;goto wait_Ping_Init;

wait_Ping_Init:
currentDeferredSet = Ping_Init_DequeueEvent();
goto transition_Ping_Init;

transition_Ping_Init:
if (__self.currentEvent == Main.Success_SM_EVENT) {
__self.currentEvent = null;
goto execute_Ping_SendPing;
} else {
return;

}


execute_Ping_SendPing:
trace("<StateLog> Machine {0}-{1} entered State {2}", __self.machineName, __self.instance, PING_State._Ping_SendPing);
payload = SM_ARG_UNION.ConstructHandle(__self);
pongId.EnqueueEvent(Main.Ping_SM_EVENT, payload, __self);
__self.currentEvent = Main.Success_SM_EVENT;
goto transition_Ping_SendPing;goto wait_Ping_SendPing;

wait_Ping_SendPing:
currentDeferredSet = Ping_SendPing_DequeueEvent();
goto transition_Ping_SendPing;

transition_Ping_SendPing:
if (__self.currentEvent == Main.Success_SM_EVENT) {
__self.currentEvent = null;
goto execute_Ping_WaitPong;
} else {
return;

}


execute_Ping_WaitPong:
trace("<StateLog> Machine {0}-{1} entered State {2}", __self.machineName, __self.instance, PING_State._Ping_WaitPong);
goto wait_Ping_WaitPong;

wait_Ping_WaitPong:
currentDeferredSet = Ping_WaitPong_DequeueEvent();
goto transition_Ping_WaitPong;

transition_Ping_WaitPong:
if (__self.currentEvent == Main.Pong_SM_EVENT) {
__self.currentEvent = null;
//testing
assert(false);
goto execute_Ping_SendPing;
} else {
return;

}

}
void run() {

dummy:
runHelper(PING_State._Ping_Init);
assert(false);

}
SM_EVENT_SET Ping_WaitPong_DequeueEvent() {
SM_EVENT_SET localIgnoredSet;
SM_EVENT_SET localDeferredSet;

dummy:
localDeferredSet = new SM_EVENT_SET;
localDeferredSet = localDeferredSet + stackDeferredSet;
localIgnoredSet = new SM_EVENT_SET;
__self.DequeueEvent(localDeferredSet, localIgnoredSet);
return localDeferredSet;

}
SM_EVENT_SET Ping_SendPing_DequeueEvent() {
SM_EVENT_SET localIgnoredSet;
SM_EVENT_SET localDeferredSet;

dummy:
localDeferredSet = new SM_EVENT_SET;
localDeferredSet = localDeferredSet + stackDeferredSet;
localIgnoredSet = new SM_EVENT_SET;
__self.DequeueEvent(localDeferredSet, localIgnoredSet);
return localDeferredSet;

}
SM_EVENT_SET Ping_Init_DequeueEvent() {
SM_EVENT_SET localIgnoredSet;
SM_EVENT_SET localDeferredSet;

dummy:
localDeferredSet = new SM_EVENT_SET;
localDeferredSet = localDeferredSet + stackDeferredSet;
localIgnoredSet = new SM_EVENT_SET;
__self.DequeueEvent(localDeferredSet, localIgnoredSet);
return localDeferredSet;

}
};

class PONG{
SM_EVENT_SET stackDeferredSet;
SM_HANDLE __self;
void runHelper(PONG_State startState) {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET savedDeferredSet;
SM_ARG_UNION payload;
bool nondet;

init:
if (startState == PONG_State._Pong_SendPong) {
goto execute_Pong_SendPong;
} else {
if (startState == PONG_State._Pong_WaitPing) {
goto execute_Pong_WaitPing;
} else {
assert(false);

}

}


execute_Pong_WaitPing:
trace("<StateLog> Machine {0}-{1} entered State {2}", __self.machineName, __self.instance, PONG_State._Pong_WaitPing);
goto wait_Pong_WaitPing;

wait_Pong_WaitPing:
currentDeferredSet = Pong_WaitPing_DequeueEvent();
goto transition_Pong_WaitPing;

transition_Pong_WaitPing:
if (__self.currentEvent == Main.Ping_SM_EVENT) {
__self.currentEvent = null;
goto execute_Pong_SendPong;
} else {
return;

}


execute_Pong_SendPong:
trace("<StateLog> Machine {0}-{1} entered State {2}", __self.machineName, __self.instance, PONG_State._Pong_SendPong);
payload = null;
if(__self.currentArg == null)
assert(false);
__self.currentArg.h.EnqueueEvent(Main.Pong_SM_EVENT, payload, __self);
__self.currentEvent = Main.Success_SM_EVENT;
goto transition_Pong_SendPong;
goto wait_Pong_SendPong;

wait_Pong_SendPong:
currentDeferredSet = Pong_SendPong_DequeueEvent();
goto transition_Pong_SendPong;

transition_Pong_SendPong:
if (__self.currentEvent == Main.Success_SM_EVENT) {
__self.currentEvent = null;
goto execute_Pong_WaitPing;
} else {
return;

}

}
void run() {

dummy:
runHelper(PONG_State._Pong_WaitPing);
assert(false);

}
SM_EVENT_SET Pong_SendPong_DequeueEvent() {
SM_EVENT_SET localIgnoredSet;
SM_EVENT_SET localDeferredSet;

dummy:
localDeferredSet = new SM_EVENT_SET;
localDeferredSet = localDeferredSet + stackDeferredSet;
localIgnoredSet = new SM_EVENT_SET;
__self.DequeueEvent(localDeferredSet, localIgnoredSet);
return localDeferredSet;

}
SM_EVENT_SET Pong_WaitPing_DequeueEvent() {
SM_EVENT_SET localIgnoredSet;
SM_EVENT_SET localDeferredSet;

dummy:
localDeferredSet = new SM_EVENT_SET;
localDeferredSet = localDeferredSet + stackDeferredSet;
localIgnoredSet = new SM_EVENT_SET;
__self.DequeueEvent(localDeferredSet, localIgnoredSet);
return localDeferredSet;

}
};

class Main{
static SM_EVENT Success_SM_EVENT;
static SM_EVENT Pong_SM_EVENT;
static SM_EVENT Ping_SM_EVENT;
static int ping_instance = 0;
static int pong_instance = 0;
static activate void run() {

dummy:
Main.Ping_SM_EVENT = SM_EVENT.Construct(Event._Ping, false);
Main.Pong_SM_EVENT = SM_EVENT.Construct(Event._Pong, false);
Main.Success_SM_EVENT = SM_EVENT.Construct(Event._Success, false);
Main.CreateMachine_PING(null);
scheduler.Remove(self);
}
static SM_HANDLE CreateMachine_PONG() {
PONG o_PONG;

dummy:
o_PONG = new PONG;
o_PONG.__self = SM_HANDLE.Construct(Machine.Pong, pong_instance);
pong_instance = pong_instance + 1;
o_PONG.stackDeferredSet = new SM_EVENT_SET;
async o_PONG.run();
o_PONG.__self.Id = scheduler.newProc;
yield;
return o_PONG.__self;

}
static SM_HANDLE CreateMachine_PING(SM_HANDLE pongId) {
PING o_PING;

dummy:
o_PING = new PING;
o_PING.__self = SM_HANDLE.Construct(Machine.Ping, ping_instance);
ping_instance = ping_instance + 1;
o_PING.stackDeferredSet = new SM_EVENT_SET;
o_PING.pongId = pongId;
async o_PING.run();
o_PING.__self.Id = scheduler.newProc;
yield;
return o_PING.__self;

}
};

