enum Machine {_Elevator, _User, _Door, _Timer};

enum Event {_after, _delete, _null, _OpenDoor, _CloseDoor, _ResetDoor, _DoorOpened, _DoorClosed, _DoorStopped, _ObjectDetected, _TimerFired, _OperationSuccess, _OperationFailure, _SendCommandToOpenDoor, _SendCommandToCloseDoor, _SendCommandToStopDoor, _SendCommandToResetDoor, _StartDoorCloseTimer, _StopDoorCloseTimer, _unit, _StopTimerReturned, _ObjectEncountered};

enum Elevator_State {_Init, _DoorClosed, _DoorOpening, _DoorOpened, _DoorOpenedOkToClose, _DoorClosing, _StoppingDoor, _StoppingTimer, _WaitingForTimer, _ReturnState};

enum User_State {_Init, _Loop};

enum Door_State {_Init, _OpenDoor, _ConsiderClosingDoor, _ObjectEncontered, _CloseDoor, _StopDoor, _Reset};

enum Timer_State {_Init, _TimerStarted, _SendTimerFired, _ConsiderStopping};

class Elevator{
SM_EVENT_SET stackDeferredSet;
SM_HANDLE myHandle;
SM_HANDLE Timer;
SM_HANDLE Door;
void runHelper(Elevator_State startState) {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;
SM_EVENT_SET savedDeferredSet;
SM_ARG_UNION payload;
bool nondet;
SM_EVENT savedCurrentEvent;
SM_ARG_UNION savedCurrentArg;

init:
if ((startState == Elevator_State._ReturnState)) {
goto execute_ReturnState;
} else {
if ((startState == Elevator_State._WaitingForTimer)) {
goto execute_WaitingForTimer;
} else {
if ((startState == Elevator_State._StoppingTimer)) {
goto execute_StoppingTimer;
} else {
if ((startState == Elevator_State._StoppingDoor)) {
goto execute_StoppingDoor;
} else {
if ((startState == Elevator_State._DoorClosing)) {
goto execute_DoorClosing;
} else {
if ((startState == Elevator_State._DoorOpenedOkToClose)) {
goto execute_DoorOpenedOkToClose;
} else {
if ((startState == Elevator_State._DoorOpened)) {
goto execute_DoorOpened;
} else {
if ((startState == Elevator_State._DoorOpening)) {
goto execute_DoorOpening;
} else {
if ((startState == Elevator_State._DoorClosed)) {
goto execute_DoorClosed;
} else {
if ((startState == Elevator_State._Init)) {
goto execute_Init;
} else {
assert(false);

}

}

}

}

}

}

}

}

}

}

;


execute_Init:
trace("<StateLog> Machine Elevator-{0} entered State Init", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "Init");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
Init_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
Timer = Main.CreateMachine_Timer(myHandle);
Door = Main.CreateMachine_Door(myHandle);
trace("<RaiseLog> Machine Elevator-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_Init;goto wait_Init;
;


wait_Init:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_Init;
;


transition_Init:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_DoorClosed;
} else {
return;

}

;


execute_DoorClosed:
trace("<StateLog> Machine Elevator-{0} entered State DoorClosed", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "DoorClosed");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
DoorClosed_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Door.EnqueueEvent(Main.SendCommandToResetDoor_SM_EVENT, payload, myHandle);
goto wait_DoorClosed;
;


wait_DoorClosed:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_DoorClosed;
;


transition_DoorClosed:
if ((myHandle.currentEvent == Main.OpenDoor_SM_EVENT)) {
goto execute_DoorOpening;
} else {
return;

}

;


execute_DoorOpening:
trace("<StateLog> Machine Elevator-{0} entered State DoorOpening", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "DoorOpening");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
DoorOpening_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Door.EnqueueEvent(Main.SendCommandToOpenDoor_SM_EVENT, payload, myHandle);
goto wait_DoorOpening;
;


wait_DoorOpening:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_DoorOpening;
;


transition_DoorOpening:
if ((myHandle.currentEvent == Main.DoorOpened_SM_EVENT)) {
goto execute_DoorOpened;
} else {
return;

}

;


execute_DoorOpened:
trace("<StateLog> Machine Elevator-{0} entered State DoorOpened", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "DoorOpened");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
DoorOpened_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Door.EnqueueEvent(Main.SendCommandToResetDoor_SM_EVENT, payload, myHandle);
payload = null;
Timer.EnqueueEvent(Main.StartDoorCloseTimer_SM_EVENT, payload, myHandle);
goto wait_DoorOpened;
;


wait_DoorOpened:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_DoorOpened;
;


transition_DoorOpened:
if ((myHandle.currentEvent == Main.OpenDoor_SM_EVENT)) {
savedDeferredSet = stackDeferredSet;
stackDeferredSet = currentDeferredSet;
runHelper(Elevator_State._StoppingTimer);
stackDeferredSet = savedDeferredSet;
if ((myHandle.currentEvent == Main.null_SM_EVENT)) {
goto wait_DoorOpened;
} else {
goto transition_DoorOpened;
}

} else {

}
if ((myHandle.currentEvent == Main.StopTimerReturned_SM_EVENT)) {
goto execute_DoorOpened;
} else {
if ((myHandle.currentEvent == Main.TimerFired_SM_EVENT)) {
goto execute_DoorOpenedOkToClose;
} else {
return;

}

}

;


execute_DoorOpenedOkToClose:
trace("<StateLog> Machine Elevator-{0} entered State DoorOpenedOkToClose", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "DoorOpenedOkToClose");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
DoorOpenedOkToClose_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Timer.EnqueueEvent(Main.StartDoorCloseTimer_SM_EVENT, payload, myHandle);
goto wait_DoorOpenedOkToClose;
;


wait_DoorOpenedOkToClose:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_DoorOpenedOkToClose;
;


transition_DoorOpenedOkToClose:
if ((myHandle.currentEvent == Main.CloseDoor_SM_EVENT)) {
savedDeferredSet = stackDeferredSet;
stackDeferredSet = currentDeferredSet;
runHelper(Elevator_State._StoppingTimer);
stackDeferredSet = savedDeferredSet;
if ((myHandle.currentEvent == Main.null_SM_EVENT)) {
goto wait_DoorOpenedOkToClose;
} else {
goto transition_DoorOpenedOkToClose;
}

} else {

}
if ((myHandle.currentEvent == Main.TimerFired_SM_EVENT)) {
goto execute_DoorClosing;
} else {
if ((myHandle.currentEvent == Main.StopTimerReturned_SM_EVENT)) {
goto execute_DoorClosing;
} else {
return;

}

}

;


execute_DoorClosing:
trace("<StateLog> Machine Elevator-{0} entered State DoorClosing", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "DoorClosing");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
DoorClosing_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Door.EnqueueEvent(Main.SendCommandToCloseDoor_SM_EVENT, payload, myHandle);
goto wait_DoorClosing;
;


wait_DoorClosing:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_DoorClosing;
;


transition_DoorClosing:
if ((myHandle.currentEvent == Main.ObjectDetected_SM_EVENT)) {
goto execute_DoorOpening;
} else {
if ((myHandle.currentEvent == Main.DoorClosed_SM_EVENT)) {
goto execute_DoorClosed;
} else {
if ((myHandle.currentEvent == Main.OpenDoor_SM_EVENT)) {
goto execute_StoppingDoor;
} else {
return;

}

}

}

;


execute_StoppingDoor:
trace("<StateLog> Machine Elevator-{0} entered State StoppingDoor", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "StoppingDoor");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
StoppingDoor_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Door.EnqueueEvent(Main.SendCommandToStopDoor_SM_EVENT, payload, myHandle);
goto wait_StoppingDoor;
;


wait_StoppingDoor:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_StoppingDoor;
;


transition_StoppingDoor:
if ((myHandle.currentEvent == Main.DoorStopped_SM_EVENT)) {
goto execute_DoorOpening;
} else {
if ((myHandle.currentEvent == Main.DoorClosed_SM_EVENT)) {
goto execute_DoorClosed;
} else {
if ((myHandle.currentEvent == Main.DoorOpened_SM_EVENT)) {
goto execute_DoorOpened;
} else {
return;

}

}

}

;


execute_StoppingTimer:
trace("<StateLog> Machine Elevator-{0} entered State StoppingTimer", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "StoppingTimer");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
StoppingTimer_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Timer.EnqueueEvent(Main.StopDoorCloseTimer_SM_EVENT, payload, myHandle);
goto wait_StoppingTimer;
;


wait_StoppingTimer:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_StoppingTimer;
;


transition_StoppingTimer:
if ((myHandle.currentEvent == Main.OperationFailure_SM_EVENT)) {
goto execute_WaitingForTimer;
} else {
if ((myHandle.currentEvent == Main.OperationSuccess_SM_EVENT)) {
goto execute_ReturnState;
} else {
return;

}

}

;


execute_WaitingForTimer:
trace("<StateLog> Machine Elevator-{0} entered State WaitingForTimer", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "WaitingForTimer");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
WaitingForTimer_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto wait_WaitingForTimer;
;


wait_WaitingForTimer:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_WaitingForTimer;
;


transition_WaitingForTimer:
if ((myHandle.currentEvent == Main.TimerFired_SM_EVENT)) {
goto execute_ReturnState;
} else {
return;

}

;


execute_ReturnState:
trace("<StateLog> Machine Elevator-{0} entered State ReturnState", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Elevator", "ReturnState");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
ReturnState_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
trace("<RaiseLog> Machine Elevator-{0} raised Event StopTimerReturned", myHandle.instance);
myHandle.currentEvent = Main.StopTimerReturned_SM_EVENT;
myHandle.currentArg = null;
goto transition_ReturnState;goto wait_ReturnState;
;


wait_ReturnState:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_ReturnState;
;


transition_ReturnState:
return;

;

}
void run() {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;

dummy:
runHelper(Elevator_State._Init);
if ((myHandle.currentEvent == Main.delete_SM_EVENT)) {
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);

} else {

}
trace("<StateLog> Unhandled event exception by machine Elevator-{0}", myHandle.instance);
assert(false);

;

}
void ReturnState_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);

;

}
void WaitingForTimer_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.OpenDoor_SM_EVENT);
localDeferredSet = (localDeferredSet + Main.CloseDoor_SM_EVENT);
localDeferredSet = (localDeferredSet + Main.ObjectDetected_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.TimerFired_SM_EVENT);

;

}
void StoppingTimer_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.OpenDoor_SM_EVENT);
localDeferredSet = (localDeferredSet + Main.CloseDoor_SM_EVENT);
localDeferredSet = (localDeferredSet + Main.ObjectDetected_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.OperationSuccess_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.OperationFailure_SM_EVENT);

;

}
void StoppingDoor_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.CloseDoor_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.DoorOpened_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.DoorClosed_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.DoorStopped_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.OpenDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.ObjectDetected_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.DoorClosed_SM_EVENT);

;

}
void DoorClosing_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.CloseDoor_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.OpenDoor_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.DoorClosed_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.ObjectDetected_SM_EVENT);

;

}
void DoorOpenedOkToClose_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.OpenDoor_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.StopTimerReturned_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.TimerFired_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.CloseDoor_SM_EVENT);

;

}
void DoorOpened_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.CloseDoor_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.TimerFired_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.StopTimerReturned_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.OpenDoor_SM_EVENT);

;

}
void DoorOpening_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.CloseDoor_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.DoorOpened_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.OpenDoor_SM_EVENT);

;

}
void DoorClosed_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.OpenDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.CloseDoor_SM_EVENT);

;

}
void Init_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
};

class User{
SM_EVENT_SET stackDeferredSet;
SM_HANDLE myHandle;
SM_HANDLE Elevator;
void runHelper(User_State startState) {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;
SM_EVENT_SET savedDeferredSet;
SM_ARG_UNION payload;
bool nondet;
SM_EVENT savedCurrentEvent;
SM_ARG_UNION savedCurrentArg;

init:
if ((startState == User_State._Loop)) {
goto execute_Loop;
} else {
if ((startState == User_State._Init)) {
goto execute_Init;
} else {
assert(false);

}

}

;


execute_Init:
trace("<StateLog> Machine User-{0} entered State Init", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "User", "Init");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
Init_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
Elevator = Main.CreateMachine_Elevator(null, null);
trace("<RaiseLog> Machine User-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_Init;goto wait_Init;
;


wait_Init:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_Init;
;


transition_Init:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_Loop;
} else {
return;

}

;


execute_Loop:
trace("<StateLog> Machine User-{0} entered State Loop", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "User", "Loop");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
Loop_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
nondet = choose(bool);
if (nondet) {
payload = null;
Elevator.EnqueueEvent(Main.OpenDoor_SM_EVENT, payload, myHandle);

} else {
nondet = choose(bool);
if (nondet) {
payload = null;
Elevator.EnqueueEvent(Main.CloseDoor_SM_EVENT, payload, myHandle);

} else {

}

}
trace("<RaiseLog> Machine User-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_Loop;goto wait_Loop;
;


wait_Loop:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_Loop;
;


transition_Loop:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_Loop;
} else {
return;

}

;

}
void run() {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;

dummy:
runHelper(User_State._Init);
if ((myHandle.currentEvent == Main.delete_SM_EVENT)) {
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);

} else {

}
trace("<StateLog> Unhandled event exception by machine User-{0}", myHandle.instance);
assert(false);

;

}
void Loop_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
void Init_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
};

class Door{
SM_EVENT_SET stackDeferredSet;
SM_HANDLE myHandle;
SM_HANDLE Elevator;
void runHelper(Door_State startState) {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;
SM_EVENT_SET savedDeferredSet;
SM_ARG_UNION payload;
bool nondet;
SM_EVENT savedCurrentEvent;
SM_ARG_UNION savedCurrentArg;

init:
if ((startState == Door_State._Reset)) {
goto execute_Reset;
} else {
if ((startState == Door_State._StopDoor)) {
goto execute_StopDoor;
} else {
if ((startState == Door_State._CloseDoor)) {
goto execute_CloseDoor;
} else {
if ((startState == Door_State._ObjectEncontered)) {
goto execute_ObjectEncontered;
} else {
if ((startState == Door_State._ConsiderClosingDoor)) {
goto execute_ConsiderClosingDoor;
} else {
if ((startState == Door_State._OpenDoor)) {
goto execute_OpenDoor;
} else {
if ((startState == Door_State._Init)) {
goto execute_Init;
} else {
assert(false);

}

}

}

}

}

}

}

;


execute_Init:
trace("<StateLog> Machine Door-{0} entered State Init", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Door", "Init");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
Init_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto wait_Init;
;


wait_Init:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_Init;
;


transition_Init:
if ((myHandle.currentEvent == Main.SendCommandToCloseDoor_SM_EVENT)) {
goto execute_ConsiderClosingDoor;
} else {
if ((myHandle.currentEvent == Main.SendCommandToOpenDoor_SM_EVENT)) {
goto execute_OpenDoor;
} else {
return;

}

}

;


execute_OpenDoor:
trace("<StateLog> Machine Door-{0} entered State OpenDoor", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Door", "OpenDoor");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
OpenDoor_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Elevator.EnqueueEvent(Main.DoorOpened_SM_EVENT, payload, myHandle);
trace("<RaiseLog> Machine Door-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_OpenDoor;goto wait_OpenDoor;
;


wait_OpenDoor:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_OpenDoor;
;


transition_OpenDoor:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_Reset;
} else {
return;

}

;


execute_ConsiderClosingDoor:
trace("<StateLog> Machine Door-{0} entered State ConsiderClosingDoor", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Door", "ConsiderClosingDoor");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
ConsiderClosingDoor_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
nondet = choose(bool);
if (nondet) {
trace("<RaiseLog> Machine Door-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_ConsiderClosingDoor;
} else {
nondet = choose(bool);
if (nondet) {
trace("<RaiseLog> Machine Door-{0} raised Event ObjectEncountered", myHandle.instance);
myHandle.currentEvent = Main.ObjectEncountered_SM_EVENT;
myHandle.currentArg = null;
goto transition_ConsiderClosingDoor;
} else {

}

}
goto wait_ConsiderClosingDoor;
;


wait_ConsiderClosingDoor:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_ConsiderClosingDoor;
;


transition_ConsiderClosingDoor:
if ((myHandle.currentEvent == Main.SendCommandToStopDoor_SM_EVENT)) {
goto execute_StopDoor;
} else {
if ((myHandle.currentEvent == Main.ObjectEncountered_SM_EVENT)) {
goto execute_ObjectEncontered;
} else {
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_CloseDoor;
} else {
return;

}

}

}

;


execute_ObjectEncontered:
trace("<StateLog> Machine Door-{0} entered State ObjectEncontered", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Door", "ObjectEncontered");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
ObjectEncontered_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Elevator.EnqueueEvent(Main.ObjectDetected_SM_EVENT, payload, myHandle);
trace("<RaiseLog> Machine Door-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_ObjectEncontered;goto wait_ObjectEncontered;
;


wait_ObjectEncontered:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_ObjectEncontered;
;


transition_ObjectEncontered:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_Init;
} else {
return;

}

;


execute_CloseDoor:
trace("<StateLog> Machine Door-{0} entered State CloseDoor", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Door", "CloseDoor");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
CloseDoor_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Elevator.EnqueueEvent(Main.DoorClosed_SM_EVENT, payload, myHandle);
trace("<RaiseLog> Machine Door-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_CloseDoor;goto wait_CloseDoor;
;


wait_CloseDoor:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_CloseDoor;
;


transition_CloseDoor:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_Reset;
} else {
return;

}

;


execute_StopDoor:
trace("<StateLog> Machine Door-{0} entered State StopDoor", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Door", "StopDoor");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
StopDoor_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Elevator.EnqueueEvent(Main.DoorStopped_SM_EVENT, payload, myHandle);
trace("<RaiseLog> Machine Door-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_StopDoor;goto wait_StopDoor;
;


wait_StopDoor:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_StopDoor;
;


transition_StopDoor:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_OpenDoor;
} else {
return;

}

;


execute_Reset:
trace("<StateLog> Machine Door-{0} entered State Reset", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Door", "Reset");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
Reset_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto wait_Reset;
;


wait_Reset:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_Reset;
;


transition_Reset:
if ((myHandle.currentEvent == Main.SendCommandToResetDoor_SM_EVENT)) {
goto execute_Init;
} else {
return;

}

;

}
void run() {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;

dummy:
runHelper(Door_State._Init);
if ((myHandle.currentEvent == Main.delete_SM_EVENT)) {
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);

} else {

}
trace("<StateLog> Unhandled event exception by machine Door-{0}", myHandle.instance);
assert(false);

;

}
void Reset_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.SendCommandToResetDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.SendCommandToOpenDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.SendCommandToCloseDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.SendCommandToStopDoor_SM_EVENT);

;

}
void StopDoor_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
void CloseDoor_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
void ObjectEncontered_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
void ConsiderClosingDoor_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.ObjectEncountered_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.SendCommandToStopDoor_SM_EVENT);

;

}
void OpenDoor_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
void Init_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.SendCommandToOpenDoor_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.SendCommandToCloseDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.SendCommandToStopDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.SendCommandToResetDoor_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.ResetDoor_SM_EVENT);

;

}
};

class Timer{
SM_EVENT_SET stackDeferredSet;
SM_HANDLE myHandle;
SM_HANDLE Elevator;
void runHelper(Timer_State startState) {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;
SM_EVENT_SET savedDeferredSet;
SM_ARG_UNION payload;
bool nondet;
SM_EVENT savedCurrentEvent;
SM_ARG_UNION savedCurrentArg;

init:
if ((startState == Timer_State._ConsiderStopping)) {
goto execute_ConsiderStopping;
} else {
if ((startState == Timer_State._SendTimerFired)) {
goto execute_SendTimerFired;
} else {
if ((startState == Timer_State._TimerStarted)) {
goto execute_TimerStarted;
} else {
if ((startState == Timer_State._Init)) {
goto execute_Init;
} else {
assert(false);

}

}

}

}

;


execute_Init:
trace("<StateLog> Machine Timer-{0} entered State Init", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Timer", "Init");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
Init_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto wait_Init;
;


wait_Init:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_Init;
;


transition_Init:
if ((myHandle.currentEvent == Main.StartDoorCloseTimer_SM_EVENT)) {
goto execute_TimerStarted;
} else {
return;

}

;


execute_TimerStarted:
trace("<StateLog> Machine Timer-{0} entered State TimerStarted", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Timer", "TimerStarted");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
TimerStarted_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
nondet = choose(bool);
if (nondet) {
trace("<RaiseLog> Machine Timer-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_TimerStarted;
} else {

}
goto wait_TimerStarted;
;


wait_TimerStarted:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_TimerStarted;
;


transition_TimerStarted:
if ((myHandle.currentEvent == Main.StopDoorCloseTimer_SM_EVENT)) {
goto execute_ConsiderStopping;
} else {
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_SendTimerFired;
} else {
return;

}

}

;


execute_SendTimerFired:
trace("<StateLog> Machine Timer-{0} entered State SendTimerFired", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Timer", "SendTimerFired");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
SendTimerFired_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
payload = null;
Elevator.EnqueueEvent(Main.TimerFired_SM_EVENT, payload, myHandle);
trace("<RaiseLog> Machine Timer-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_SendTimerFired;goto wait_SendTimerFired;
;


wait_SendTimerFired:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_SendTimerFired;
;


transition_SendTimerFired:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_Init;
} else {
return;

}

;


execute_ConsiderStopping:
trace("<StateLog> Machine Timer-{0} entered State ConsiderStopping", myHandle.instance);
invokeplugin("StateCoveragePlugin.dll", "Timer", "ConsiderStopping");
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
ConsiderStopping_CalculateDeferredAndIgnoredSets(currentDeferredSet, currentTransitionSet, currentIgnoredSet);
nondet = choose(bool);
if (nondet) {
payload = null;
Elevator.EnqueueEvent(Main.OperationFailure_SM_EVENT, payload, myHandle);
payload = null;
Elevator.EnqueueEvent(Main.TimerFired_SM_EVENT, payload, myHandle);

} else {
payload = null;
Elevator.EnqueueEvent(Main.OperationSuccess_SM_EVENT, payload, myHandle);

}
trace("<RaiseLog> Machine Timer-{0} raised Event unit", myHandle.instance);
myHandle.currentEvent = Main.unit_SM_EVENT;
myHandle.currentArg = null;
goto transition_ConsiderStopping;goto wait_ConsiderStopping;
;


wait_ConsiderStopping:
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);
goto transition_ConsiderStopping;
;


transition_ConsiderStopping:
if ((myHandle.currentEvent == Main.unit_SM_EVENT)) {
goto execute_Init;
} else {
return;

}

;

}
void run() {
SM_EVENT_SET currentDeferredSet;
SM_EVENT_SET currentTransitionSet;
SM_EVENT_SET currentIgnoredSet;

dummy:
runHelper(Timer_State._Init);
if ((myHandle.currentEvent == Main.delete_SM_EVENT)) {
currentDeferredSet = new SM_EVENT_SET;
currentTransitionSet = new SM_EVENT_SET;
currentIgnoredSet = new SM_EVENT_SET;
myHandle.DequeueEvent(-1, currentDeferredSet, currentTransitionSet, currentIgnoredSet);

} else {

}
trace("<StateLog> Unhandled event exception by machine Timer-{0}", myHandle.instance);
assert(false);

;

}
void ConsiderStopping_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.StartDoorCloseTimer_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
void SendTimerFired_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.StartDoorCloseTimer_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);

;

}
void TimerStarted_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localDeferredSet = (localDeferredSet + Main.StartDoorCloseTimer_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.unit_SM_EVENT);
localTransitionSet = (localTransitionSet + Main.StopDoorCloseTimer_SM_EVENT);

;

}
void Init_CalculateDeferredAndIgnoredSets(SM_EVENT_SET localDeferredSet, SM_EVENT_SET localTransitionSet, SM_EVENT_SET localIgnoredSet) {

dummy:
localDeferredSet = (localDeferredSet + stackDeferredSet);
localTransitionSet = (localTransitionSet + Main.StartDoorCloseTimer_SM_EVENT);
localIgnoredSet = (localIgnoredSet + Main.StopDoorCloseTimer_SM_EVENT);

;

}
};

class Main{
static int Timer_instance;
static int Door_instance;
static int User_instance;
static int Elevator_instance;
static SM_EVENT ObjectEncountered_SM_EVENT;
static SM_EVENT StopTimerReturned_SM_EVENT;
static SM_EVENT unit_SM_EVENT;
static SM_EVENT StopDoorCloseTimer_SM_EVENT;
static SM_EVENT StartDoorCloseTimer_SM_EVENT;
static SM_EVENT SendCommandToResetDoor_SM_EVENT;
static SM_EVENT SendCommandToStopDoor_SM_EVENT;
static SM_EVENT SendCommandToCloseDoor_SM_EVENT;
static SM_EVENT SendCommandToOpenDoor_SM_EVENT;
static SM_EVENT OperationFailure_SM_EVENT;
static SM_EVENT OperationSuccess_SM_EVENT;
static SM_EVENT TimerFired_SM_EVENT;
static SM_EVENT ObjectDetected_SM_EVENT;
static SM_EVENT DoorStopped_SM_EVENT;
static SM_EVENT DoorClosed_SM_EVENT;
static SM_EVENT DoorOpened_SM_EVENT;
static SM_EVENT ResetDoor_SM_EVENT;
static SM_EVENT CloseDoor_SM_EVENT;
static SM_EVENT OpenDoor_SM_EVENT;
static SM_EVENT null_SM_EVENT;
static SM_EVENT delete_SM_EVENT;
static SM_EVENT after_SM_EVENT;
static activate void run() {

dummy:
Main.after_SM_EVENT = SM_EVENT.Construct(Event._after, false);
Main.delete_SM_EVENT = SM_EVENT.Construct(Event._delete, false);
Main.null_SM_EVENT = SM_EVENT.Construct(Event._null, false);
Main.OpenDoor_SM_EVENT = SM_EVENT.Construct(Event._OpenDoor, true);
Main.CloseDoor_SM_EVENT = SM_EVENT.Construct(Event._CloseDoor, true);
Main.ResetDoor_SM_EVENT = SM_EVENT.Construct(Event._ResetDoor, false);
Main.DoorOpened_SM_EVENT = SM_EVENT.Construct(Event._DoorOpened, false);
Main.DoorClosed_SM_EVENT = SM_EVENT.Construct(Event._DoorClosed, false);
Main.DoorStopped_SM_EVENT = SM_EVENT.Construct(Event._DoorStopped, false);
Main.ObjectDetected_SM_EVENT = SM_EVENT.Construct(Event._ObjectDetected, false);
Main.TimerFired_SM_EVENT = SM_EVENT.Construct(Event._TimerFired, true);
Main.OperationSuccess_SM_EVENT = SM_EVENT.Construct(Event._OperationSuccess, false);
Main.OperationFailure_SM_EVENT = SM_EVENT.Construct(Event._OperationFailure, false);
Main.SendCommandToOpenDoor_SM_EVENT = SM_EVENT.Construct(Event._SendCommandToOpenDoor, true);
Main.SendCommandToCloseDoor_SM_EVENT = SM_EVENT.Construct(Event._SendCommandToCloseDoor, true);
Main.SendCommandToStopDoor_SM_EVENT = SM_EVENT.Construct(Event._SendCommandToStopDoor, true);
Main.SendCommandToResetDoor_SM_EVENT = SM_EVENT.Construct(Event._SendCommandToResetDoor, true);
Main.StartDoorCloseTimer_SM_EVENT = SM_EVENT.Construct(Event._StartDoorCloseTimer, true);
Main.StopDoorCloseTimer_SM_EVENT = SM_EVENT.Construct(Event._StopDoorCloseTimer, true);
Main.unit_SM_EVENT = SM_EVENT.Construct(Event._unit, false);
Main.StopTimerReturned_SM_EVENT = SM_EVENT.Construct(Event._StopTimerReturned, false);
Main.ObjectEncountered_SM_EVENT = SM_EVENT.Construct(Event._ObjectEncountered, false);
Elevator_instance = 0;
User_instance = 0;
Door_instance = 0;
Timer_instance = 0;
Main.CreateMachine_User(null);

;

}
static SM_HANDLE CreateMachine_Timer(SM_HANDLE Elevator) {
Timer o_Timer;

dummy:
o_Timer = new Timer;
o_Timer.myHandle = SM_HANDLE.Construct(Machine._Timer, Timer_instance);
Timer_instance = (Timer_instance + 1);
o_Timer.stackDeferredSet = new SM_EVENT_SET;
o_Timer.Elevator = Elevator;
async o_Timer.run();
yield;
return o_Timer.myHandle;

;

}
static SM_HANDLE CreateMachine_Door(SM_HANDLE Elevator) {
Door o_Door;

dummy:
o_Door = new Door;
o_Door.myHandle = SM_HANDLE.Construct(Machine._Door, Door_instance);
Door_instance = (Door_instance + 1);
o_Door.stackDeferredSet = new SM_EVENT_SET;
o_Door.Elevator = Elevator;
async o_Door.run();
yield;
return o_Door.myHandle;

;

}
static SM_HANDLE CreateMachine_User(SM_HANDLE Elevator) {
User o_User;

dummy:
o_User = new User;
o_User.myHandle = SM_HANDLE.Construct(Machine._User, User_instance);
User_instance = (User_instance + 1);
o_User.stackDeferredSet = new SM_EVENT_SET;
o_User.Elevator = Elevator;
async o_User.run();
yield;
return o_User.myHandle;

;

}
static SM_HANDLE CreateMachine_Elevator(SM_HANDLE Timer, SM_HANDLE Door) {
Elevator o_Elevator;

dummy:
o_Elevator = new Elevator;
o_Elevator.myHandle = SM_HANDLE.Construct(Machine._Elevator, Elevator_instance);
Elevator_instance = (Elevator_instance + 1);
o_Elevator.stackDeferredSet = new SM_EVENT_SET;
o_Elevator.Timer = Timer;
o_Elevator.Door = Door;
async o_Elevator.run();
yield;
return o_Elevator.myHandle;

;

}
};

